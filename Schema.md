# CNN для распознавания лиц

Ниже — **общая схема решения**, последовательно и без кода.

* * *

Исходные данные
---------------

У тебя есть:

*   несколько **пользователей**
*   у каждого пользователя — **несколько embedding’ов** (по разным фото)
*   новый embedding с камеры: `E_new`

Каждый embedding:

*   `float32`
*   размер 512
*   L2-нормализован

* * *

Ключевая идея
-------------

Ты **не классифицируешь**, а делаешь **поиск ближайших embedding’ов**.

Задача формулируется так:

> «Есть ли в базе embedding, достаточно близкий к новому,  
> и если да — какому пользователю он принадлежит»

* * *

Общая схема (логически)
-----------------------

### Шаг 1. Новый embedding

*   с камеры получаешь `E_new`

* * *

### Шаг 2. Сравнение со ВСЕМИ embedding’ами в базе

Для каждого embedding в БД:

*   считаешь расстояние до `E_new`
*   используешь **одну метрику**:
    *   cosine distance
    *   или L2 distance (чаще для ArcFace)

Результат:

```
(person_id, embedding_id, distance)
```

* * *

### Шаг 3. Агрегация по пользователям

Так как у пользователя **несколько embedding’ов**, ты **обязан агрегировать**.

Есть 3 стандартных стратегии.

#### Вариант A (самый надёжный)

**Минимальное расстояние**

```
score(person) = min(distance_i)
```

Интерпретация:

> «Есть ли у этого пользователя хотя бы одно фото, очень похожее»

Это **де-факто стандарт**.

* * *

#### Вариант B

**Среднее расстояние**

```
score(person) = mean(distance_i)
```

Хуже работает:

*   портится из-за плохих фото
*   чувствителен к выбросам

Используется редко.

* * *

#### Вариант C (продвинутый)

**Средний embedding пользователя**

*   заранее считаешь `mean_embedding` для каждого пользователя
*   сравниваешь `E_new` только с ним

Быстро, но:

*   хуже при малом числе фото
*   обычно комбинируют с вариантом A

* * *

### Шаг 4. Выбор лучшего кандидата

После агрегации:

```
person_id → score
```

Выбираешь:

```
best_person = argmin(score)
best_score = min(score)
```

* * *

### Шаг 5. Решение «известный / новый»

Используешь **порог**.

Для ArcFace (L2):

*   типично `0.4 – 0.6`

Правило:

```
if best_score < threshold:
    пользователь найден
else:
    новый пользователь
```

* * *

Нужно ли группировать заранее?
------------------------------

### Коротко: **логически — да, физически — нет**

Что это значит:

*   **в базе** embedding’и можно хранить плоско:
    ```
    embedding_id | person_id | embedding
    ```
*   **группировка делается в коде**, на этапе сравнения

Ты **не обязан**:

*   кластеризовать
*   строить отдельные структуры по людям
*   обучать классификатор

* * *

Итоговая логика (в одном абзаце)
--------------------------------

Новый embedding сравнивается со всеми embedding’ами в базе, расстояния агрегируются по пользователям (обычно через минимум), выбирается пользователь с наименьшим расстоянием, и по порогу принимается решение — известный это человек или новый. Предварительная кластеризация не нужна, достаточно логической группировки по `person_id`.

* * *

